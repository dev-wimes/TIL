# SwiftUI by Tutorials

> Reference: https://www.raywenderlich.com/books/swiftui-by-tutorials/

## 2. Getting Start

* `@main` auttribute는 해당 struct가 app의 진입점을 표시한다.
* tip: Xcode canvas에서 resume의 short cut은 `option-cammand-p` 이다.
* SwiftUI는 선언적이다. UI가 어떻게 보이는지 선언하고 SwiftUI는 선언한 코드를 완료하는 효율적인 코드로 변환해준다.
* SwiftUI는 재사용가능한 매개변수화 된 View가 권장된다.
* SwiftUI 용어 정리
  * modifier: UIKit의 요소의 프로퍼티를 설정하는 것과 대치되는 것 SwiftUI에서는 modifier라고 한다.(backgroundColor, Font, padding 등)
  * container views : UIKit에서 StackView를 떠올려보면 쉽게 이해가능. HStack, VStack 등을 이용해 app의 UI를 생성해주고 담는 그릇이라고 생각하면 됨
* `$` : `guest.red`는 read-only한 value이다. 그러나 `$guess.red` 는 read-write binding이다. user가 해당 value를 변경시킬 때마다 업데이트할 때 필요한 symbol이다.
  * https://stackoverflow.com/questions/56551131/what-does-the-dollar-sign-do-in-this-example
* View내부에서 사용할 binding value가 필요하다면, `@State`, View와 View사이에서 binding value가 필요하다면 `@Binding` 을 사용한다.
  * `@Binding` value는 상위 view에서 초기값을 받고, 부모 view의 `@State`같은 값을 양방향으로 연결되도록 해준다.

## 3. Diving Deeper Into SwiftUI

* modifier인 `fill(_:style:)` 은 Shape에만 적용할 수 있다. (순서에 유의)

* `ButtonStyle` 은 Button의 label과 사용자가 버튼을 눌렀을 때 Configuration을 통해 label의 Bool값(눌렀으니 true)를 전달한다.

* container인 `Group`은 무언가를 수행하는 것이 아님.
  View content를 위한 affordance(행동유동성)임.
  예를 들어 VStack에 11개 이상의 View가 잇다면 Error남.
  이때 Group을 이용해서 10개를 한 그룹, 나머지 1개를 한 그룹으로 만들어서 사용한다.
  여러개의 content type의 instance들을 단일 unit으로 만들어 준다.

* Preview > Color Scheme > Dark로 Dark모드를 설정할 수 있다.
  
  <img src="2.GettingStart~.assets/image-20220212155246102.png" alt="image-20220212155246102" style="zoom:50%;" />
  
* 또한 실행하고 나서도 Deubg 도구 모음 에서도 Envrionment Override > Appearance에서도 Dark모드를 설정할 수 있다.
  
  <img src="2.GettingStart~.assets/image-20220212193104537.png" alt="image-20220212193104537" style="zoom:50%;" />
  
* VStack 의 sub view에 모든 텍스트의 폰트를 변겨할 수 있다.

  ```swift
  VStack{
    ...
  }
  .font(.headline)
  ```

  그러나 특정 view만큼은 `.headline` 폰트를 설정하고 싶지 않을 때 아래와 같이 하면 HStack 내부의 모든 view는 `headline`이 아닌 `.subheadline` 폰트를 사용한다.

  ```swift
  VStack{
    ...
    HStack{
      
    }
    .font(.subheadline)
  }
  .font(.headline)
  ```

* preview device를 변경하고 싶다면 아래처럼 할 수 있다.

  ```swift
  Contentview()
  	.previewDevice("iPhone 8")
  ```

* 절대 크기가 아닌 상대 크기를 사용하려면 `GeometryReader`로 화면크기를 가져와서 설정을 해줘야 한다.
  아래 처럼 사용할 수 있다.

  ```swift
  let circleSize: CGFloat = 0.275
  ...
  
  GeometryReader { proxy in
  	ZStack{
      ColorCircle(
        rgb: ...,
        // 전체 화면 height값의 0.275배가 Circle의 크기로 설정
        size: proxy.size.height * circleSize
      )
      ...
    }
  }
  ```

* Preview를 한번에 여러개 볼 수 있다.
  Canvas의 Preview에서 아래 버튼을 클릭하면 
  
  ![image-20220212195659530](2.GettingStart~.assets/image-20220212195659530.png)
  
  `PreviewProvider` 에서 `Group` 으로 묶인 View들을 볼 수 있다.
  원하는 Device 별로 설정해주면 된다.
  
  ```swift
  struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        Group {
            ContentView(guess: RGB())
                .previewDevice("iPhone 13 Pro")
            ContentView(guess: RGB())
                .previewDevice("iPhone 8")
            ContentView(guess: RGB())
                .previewDevice("iPhone 13 Mini")
        }
    }
  }
  ```

## 4. Test & Debugging

> Reference: https://ntomios.tistory.com/m/32

* 일반적인 Test의 복잡성

  * UI테스트 > 통합(intergration) 테스트 > 단위(unit) 테스트

* 디버그를 위해 중단점을 추가하고 실행했는데 앱이 중단되지 않으면 해당 인터페이스에 요소가 포함되지 않았음을 알 수 있다.

* 디버그 바

  <img src="2.GettingStart~.assets/image-20220212212434465.png" alt="image-20220212212434465" style="zoom:50%;" />

  * Step Over: 메서드를 포함하여 현재 코드 줄을 실행
  * Step Into: 현재 코드 줄도 실행하지만 메서드 호출이 있는 경우 해당 메서드 내부의 첫 번째 코드 줄에서 일시 중지 된다.
  * Step Out: 메서드의 끝까지 코드를 실행한다.

* 디버그 콘솔의 `lldb` 프롬프트에서 다음 명령어를 수행한다.
  `po _pendingOperation`
  `po` 를 이용해서 instance의 상태를 검사할 수 있다. 변수 이름의 시작부분에 있는 under bar(_)에 유의하자. SwiftUI View내에서 변수 이름에 under bar를 접두어를 붙여야 한다. 
  아래처럼 코드에 적힌 `pendingOperatio` 변수의 내용이 표시된다.

  ![image-20220212213303536](2.GettingStart~.assets/image-20220212213303536.png)

* UI 테스트를 하려면 

  * File > New > Target... > iOS > UI Testing Bundle > Next
    
    ![image-20220212213651640](2.GettingStart~.assets/image-20220212213651640.png)
    
  * Test할 Project를 선택하고 Finish를 누른다.
    
    ![image-20220212213753441](2.GettingStart~.assets/image-20220212213753441.png)
    
  * Project hierachy에 SwiftCalcUItests라는 새 그룹을 볼 수 있다.
    그룹 내부에 있는 ***Tests.swift 파일을 열어서 보도록 한다.
    `XCTest`가 import되어 있고, 모든 테스트 클래스가 동작을 상속하는 `XCTestCase`을 상속하고 있다.

    ```swift
    import XCTest
    
    class SwiftCalcUITests: XCTestCase {
      ...
    }
    ```

  * Xcode ui test 템플릿에서 제공되는 4가지 기본 메서드도 볼 수 있다. 처음 두가지 메서드는 중요하다.

    * 테스트 프로세스는 클래스의 각 테스트 메소드 앞에 `setUpWithError()`를 호출 한 다음 
      각 테스트 방법이 완료된 후 `tearDownWithError()`를 호출한다.

    * 기억하자: 테스트는 알려진 input에 예상되는 ouput을 생성하지는지 확인 하는 것이다.
      `setUpWithError()` 는 각 테스트 방법이 시작되기 전에 앱이 이 알려진 상태에 있는지 확인하는데 사용한다.
      `tearDownWithError()` 는 다음 테스트를 위해 알려진 시작 조건으로 돌아갈 수 있도록 각 테스트 후에 초기화 하는데 사용한다.

    * `setUpWithError()`를 보면 아래와 같은 코드가 default로 적혀 있다.

      ```swift
      continueAfterFailure = false
      ```

      이는 오류가 발생하면 테스트를 중지한다. false로 설정하면 실패 후 테스트가 종료, true이면 keep going

  * Xcode ui test 템플릿에서 제공되는 세번째 method는 `testExample()` 이다.

    * sample 테스트가 이루어지는 곳.
    * method 이름 옆에 회색 다이아몬드가 있고, 이는 Xcode가 테스트로 인식하고 있다는 의미이다.
    * test의 이름은 "test"로 시작해야 한다. (안하면 무시하고 건너뜀)

  * UI테스트는 "지금 막 시작된"상태의 앱이므로, 앱이 막 시작된 것처럼 각 테스트를 작성할 수 있다.
    실행할 때마다 앱 상태가 재설정된다는 의미가 아님.
    `setUpWithError()`및 `tearDownWithError()` 메서드를 사용하여 각 테스트 전에 앱이 알려진 특정 상태인지 확인하고 테스트 중에 변경된 사항을 정리한다.
    테스트가 실행될 때 설정, 데이터, 위치, 기타 정보가 있을 것으로 예상되는 경우 해당 정보를 설정해야 한다.

* UI 테스트를 시작하는 방법

  * Xcode에서 Command+6을 눌러 왼쪽의 Hierachy에 Test Navigator로 이동할 수 있다.
    여기서 method 이름위로 마우스를 올리면 회색 재생표시를 눌러 테스트 가능

    ![image-20220213001415828](2.GettingStart~.assets/image-20220213001415828.png)

  * 코드 상에서 왼쪽 회색 다이아몬드에 마우스를 올리면 회색 재생표시를 눌러 테스트 가능

    ![image-20220213001437651](2.GettingStart~.assets/image-20220213001437651.png)

  * `app.launch()` 다음 줄에 중단점을 걸고 테스트를 실행하면 lldb 명령프롬프트가 출력되면서 멈춘다.
    이때 `po app` 명령을 입력하면 아래와 같은 형태로 출력이 된다.

    ![image-20220213173125113](2.GettingStart~.assets/image-20220213173125113.png)

    XCUIElement의 하위 클래스인 XCUIApplication으로 선언한 `app` 객체를 검사하고 있다. 모든 UI 테스트에서 이 객체로 작업하게 된다.

    `app` 객체는 앱의 모든 UI 요소의 트리를 보여준다. 이러한 각 요소도 XCUIElement 타입이다. 표시되는 트리에서 항목을 선택하기 위해 앱 개체에 대해 필터 쿼리를 실행하여 `app`의 UI 요소에 액세스할 수 있다.

* UI 요소에 접근 방법

  * 아래 명령어를 보자

    ```swift
    let memoryButton = app.buttons["M+"]
    memoryButton.tap()
    ```

    `XCuIAPplication`에는 각 UI 객체에 대한 요소 집합이 들어 있다. 
    이 쿼리는 앱의 `.buttons`에 대해서만 필터링한다. 그런 다음 `m+`의 label이 있는 요소로 필터링한다.

    SwiftUI 앱은 플랫폼의 기본 요소로 렌더링된다. 그들은 새로운 구성 요소가 아님.
    SwiftUI는 인터페이스를 정의하는 새로운 방법을 제공하지만 여전히 플랫폼의 기존 요소를 사용한다. SwiftUI `Button`은 iOS에서는 `UIButton`이 되고 macOS에서는 `NSButton`이 된다.
    이 앱에서 필터는 이전에 `po app`의 출력에서 본 다음 label과 일치한다.
    ![image-20220213174026566](2.GettingStart~.assets/image-20220213174026566.png)

    `Button`객체가 있으면 `Button`의 `tap()`을 호출한다.
    이 메서드는 버튼을 탭하는 사람을 시뮬레이션한다.

    이대로 실행하면 app이 실행되고 button을 탭하고 해당 테스트는 끝이 난다.

* UI 읽기

  이전에 Button의 label을 이용해 "M+" Button을 찾았다.
  그렇다면 특정 인터페이스요소나 label이 실시간으로 변경되는 인터페이스에는 접근은 어떻게 하는가?

  인터페이스 요소에 속성을 추가하면 된다.

  ```swift
  Text("0")
  	// 아래 accessibilityIdentifier(_:)를 추가하면 
  	// Text("0")를 test 환경에서 "display"라는 이름으로 접근할 수 있다.
  	.accessibilityIdentifier("display")
  ```

* 테스트 코드 작성

  ```swift
  func testPressMemoryPlusAtAppStartShowZeroInDisplay() throws{
   let app = XCUIApplication()
    app.launch()
  
    let memoryButton = app.buttons["M+"]
    memoryButton.tap()
  
    // staticTexts으로  accessbilityIdentifier(_:)를 이용해 등록한 요소를 찾을 수 있다.
    // return값은 대부분의 UI요소와 마찬가지로 XCUIElement이다.
    let display = app.staticTexts["display"]
    // label값을 리턴받는다.
    let displayText = display.label
    // 해당 label이 원하는 결과인 "0"과 같은지 확인
    XCTAssert(displayText == "0") 
  }
  ```

  위코드를 실행켰을 때 통과라면 초록색 체크표시, 그렇지 않다면 빨간색 x표시가 나오게 된다.

  ![image-20220213184117103](2.GettingStart~.assets/image-20220213184117103.png)

  ![image-20220213184004291](2.GettingStart~.assets/image-20220213184004291.png)

* 더 복잡한 테스트 추가

  아래 코드처럼 각 버튼을 클릭하고 display ui요소의 값을 점검할 수 있다.

  ```swift
  func testAddingTwoDigits(){
    let app = XCUIApplication()
    app.launch()
  
    let threeButton = app.buttons["3"]
    threeButton.tap()
  
    let addButton = app.buttons["+"]
    addButton.tap()
  
    let fiveButton = app.buttons["5"]
    fiveButton.tap()
  
    let equalButton = app.buttons["="]
    equalButton.tap()
  
    let display = app.staticTexts["display"]
    let displayText = display.label
    XCTAssert(displayText == "8")
  }
  ```

  위 코드를 수행했을 때 test fail이 나온다.

  `XCTAssert()`문에 중단점을 걸고 `po displayText` 를 해보니 아래 처럼 나온다.

  ![image-20220213185147505](2.GettingStart~.assets/image-20220213185147505.png)

  unit test에서는 8이라는 값이 통과가 되지만, ui test에서는 그렇지 못하다. 

  이 처럼 background에서 발생하는 요소의 값을 그대로 적는 것이 아닌 ui에서 출력되는 값을 그대로 적어줘야 한다. ui테스트는 이같은 상황을 주의해야 한다.

* User Interaction 시뮬레이션

  아래코드는 ui요소를 스와이프하면 지워지는 제스처에 대한 ui test이다.

  ```swift
  func testSwipeToClearMemory(){
    let app = XCUIApplication()
    app.launch()
  
    let threeButton = app.buttons["3"]
    threeButton.tap()
    let fiveButton = app.buttons["5"]
    fiveButton.tap()
  
    let memoryButton = app.buttons["M+"]
    memoryButton.tap()
  
    let memoryDisplay = app.staticTexts["memoryDisplay"]
  
    // exists는 해당 요소가 존재할 때 true이다.
    XCTAssert(memoryDisplay.exists)
    // swipeLeft 제스처를 수행한다.
    memoryDisplay.swipeLeft()
    // XCTAssertFalse는 parameter가 false일 경우 통과이다.
    // 즉, 스와이프 이후 memoryDisplay가 삭제되야 하므로 XCTAssertFalse를 사용한다.
    XCTAssertFalse(memoryDisplay.exists)
  }
  ```

  이 밖에도 ui test를 위한 자주 사용하는 프로퍼티나 메서드가 존재한다

  * `.isHittable`:  요소가 존재하고, 사용자가 현재 위치에서 클릭, 탭 혹은 누를 수 있을 경우 hittable 하다.
    스크린을 벗어난 요소는 존재할 수 있으나 hittable하지 않다.
  * `.typeText()`: 이 메서드는 사용자가 "호출 control"에 텍스트를 입력하는 것처럼 동작
    (사용자가 입력하는 것처럼 작동한다.)
  * `.press(forDuration:)`: 지정된 시간 동안 한 손가락 터치를 수행할 수 있다.
  * `.press(forDuration:thenDragTo:)`: 스와이프 메서드는 제스처의 속도를 보장하지 않는다. 이 방법을 사용하여 더 정확한 드래그 동작을 수행할 수 있다.
  * `.waitForExistence():요소가 화면에 즉시 나타나지 않아 일시 중지가 필요한 경우 유용하다.

* 여러 플랫폼 테스트

  SwiftUI의 특징 중 하나는 Apple Multiple Platform이 있다. iOS 전용으로 만든 앱은 아주 적은 작업으로 macOS앱이 될 수 있다.그러나 앱과 테스트가 모든 플랫폼에서 제대로 동작하기 위해서는 주의해야 할 사항이 있다.

  mac에는 swipeLeft가 없다.
  모든 작업이 모든 운영체제에서 1:1로 상응하는 것이 아니다.

  이때 조건부 컴파일 블록을 사용하여 해결하도록 한다.

  ```swift
  // 멀티플랫폼인 mac catalyst는 테스트에서 제외
  #if !targetEnvironment(macCatalyst)
  let app = XCUIApplication()
  app.launch()
  ...
  XCTAssert(memoryDisplay.exists)
  memoryDisplay.swipeLeft()
  XCTAssertFalse(memoryDisplay.exists)
  #endif
  
  // 특정 운영체제를 제외할 수도있음. iOS, iPadOS, macOS, watchOS, tvOS, Linux 중 하나를 넣으면 된다.
  #if !os(watchOS)
  // your XCTest code
  #endif
  ```

## 5. Intro to Controls: Text & Image

* 일반적으로 많이 사용되는 Control인 `Text`와 `Image` 에 대해 보도록 한다.

* 오른쪽에 있는 inspector나, canvas에서 option + command로 해당 오브젝트를 클릭해 modifier를 적용할 수 있다.

  <img src="2.GettingStart~.assets/image-20220213211155738.png" alt="image-20220213211155738" style="zoom:50%;" />

  <img src="2.GettingStart~.assets/image-20220213211214236.png" alt="image-20220213211214236" style="zoom:50%;" />

* SiwftUI가 제공하는 modifier에는 두가지 범주가 있다.

  * 모든 `View`에서 사용할 수 있는 프로토콜과 함께 번들로 제공되는 modifier
  * 해당 유형의 인스턴스에만 사용할 수 있는 특정 타입의 modifier

  아래 처럼 modifier가 어떤 것들이 있는지 찾아볼 수 있다.

  <img src="2.GettingStart~.assets/image-20220213211456513.png" alt="image-20220213211456513" style="zoom:50%;" />

* 과연 modifier가 효율적인가?

  모든 modifier는 새로운 `View`를 리턴하고 있는데, 이 프로세스가 실제로 효율적인가에 대한 의문이 생긴다.

  SwiftUI는 modifier를 호출할 때마다 새로운 `View`에 이전 `View`를 포함한다.
  즉, `View` 스택을 생성하는 재귀 프로세스이다.
  직관적으로 이것은 자원 낭비처럼 보일 수 있다. 그러나 사실 SiwftUI가 이 스택을 View의 실제 랜더링에 사용되는 효율적인 데이터 구조로 평면화(flat)한다.

  즉, `View` 효율성에 미칠 염려없이 자유롭게 사용가능하다.

* modifier의 적용 순서가 중요한가?

  대부분의 경우에는 NO이지만, 일단은 답은 YES이다.

  예를 들어 modifier로 굵게 적용한다음 빨간색으로 만드는 경우,

  ```swift
  Text("Welcome to Kuchi")
    .bold()
    .foregroundColor(.red)
  ```

  먼저 빨간색으로 만든 다음 굵게 표시하는 경우

  ```swift
  Text("Welcome to Kuchi")
    .foregroundColor(.red)
    .bold()
  ```

  둘 차이를 느끼지 못할 것이다.

  ![image-20220213212231882](2.GettingStart~.assets/image-20220213212231882.png)

  그러나 배경색을 적용한 다음 padding을 적용하는 것과 padding을 적용하고 배경색을 적용하는 것은 서로 다른 결과가 나타난다.

  ```swift
  Text("Welcome to Kuchi")
    .background(Color.red)
    .padding()
  ```

  ```swift
  Text("Welcome to Kuchi")
    .padding()
    .background(Color.red)
  ```

  ![image-20220213212358278](2.GettingStart~.assets/image-20220213212358278.png)

  배경색을 적용하는 View가 경우에 따라 다를 수 있기 때문이다. modifier를 적용하면 새로운 `View`를 리턴하기 때문에 어떤 View를 기준으로 modifier를 적용하냐에 따라 다르다는 얘기.

  ```swift
  Text("Welcome to Kuchi")
    .background(Color.yellow)
    .padding()
    .background(Color.red)
  ```

  ![image-20220213212535709](2.GettingStart~.assets/image-20220213212535709.png)

* modifier를 적용하지 않고 이미지를 생성하면 SiwftUI는 이미지를 기본 해상도로 랜더링하고 이미지의 종횡비를 유지한다.

* 이미지의 크기를 조정하려면 inset 및 resizing mode라는 두 가지 매개변수를 사용하는 `resizable` modifier를 적용해야 한다. resizing mode는 `.tile` 또는 `.stretch`일 수 있다.

  * 매개변수를 제공하지 않으면 SwiftUI는 네 방향(top, bottom, leading, trailling) 및 `.stretch` resizaing mode 모두에 대해 inset이 없다고 가정한다.

  아래 코드를 보자. width와 height을 30 frame에 이미지를 넣었다.

  ```swift
  Image(systemName: "table")
  	.frame(width: 30, height: 30)
  ```

  그러나 실행시키면 이미지는 원래 크기이고 preview에서 이미지를 클릭해보면 30/30 크기만큼 테두리가 보인다. View의 크기는 늘었지만, 이미지자체의 크기는 그대로인 상황.
  ![image-20220213215115293](2.GettingStart~.assets/image-20220213215115293.png)

  `frame` 앞에 `resizable` modifier를 붙여준다.

  ```swift
  Image(systemName: "table")
    .resizable()
    .frame(width: 30, height: 30)
  ```

  > **참고**
  >
  > 이미지에 포인트로 절대 크기를 지정했다. 그러나 접근성을 위해 SwiftUI가 이미지 또는 일반적인 UI cotent 크기를 조정하는 방법을 결정하는 것이 좋다.
  >
  > 이에 대한 내용은 나중에 배우도록 하자.

* 이미지 modifier(수정자)적용 예

  ```swift
  Image(systemName: "table")
    .resizable()
    .frame(width: 30, height: 30)
  	// 모서리 반경을 이미지 크기의 절반으로 설정
    .cornerRadius(30/2)
  	// 얇은 회색 테두리를 추가
    .overlay(Circle().stroke(Color.gray, lineWidth: 1))
  	// 밝은 회색 배경색을 추가
  	.background(Color(white: 0.9))
  	// Circle Shape를 사용하여 결과 이미지를 잘라 넘어간 색상배경을 제거
    .clipShape(Circle())
  	// 전경색을 빨간색으로 설정
    .foregroundColor(.red)
  ```

  ![image-20220213215713562](2.GettingStart~.assets/image-20220213215713562.png)

* 특별한 경우를 제외하고는 `View` 의 body는 하나의 subview만 허용가능하다.

* 이미지 수정자 적용 예2

  ```swift
  // 추가하는 image 이름, Assets.xcassets 에 있는 이미지 이름을 통해 가져온다.
  Image("welcome-background", bundle: nil)
  	// 크기를 조정할 수 있도록 한다.
    .resizable()
  	// 원본 비율을 기준으로 부모내에서 완전히 보이도록 이미지를 최대화한다.
    .scaledToFit()
  	// 기본적으로 1 : 1 인 종횡비를 설정한다.
  	// ContentMode를 .Fill으로 설정하면 이미지가 전체 상위 뷰를 채우므로 이미지의 일부가 뷰의 경계를 초과하여 확장된다.
    .aspectRatio(1/1, contentMode: .fill)
  	// safearea inset을 무시하고 safearea 외부로 view를 확장하여 전체 상위 공간을 차지하도록 한다.
    // 현재 모든 가장자리를 무시하지만 가장자리별로 구성할 수도 있다. 그렇게 하려면 무시할 가장자리 배열을 전한다 (.top, .bottom, .leading, .trailing) 
  	// 뿐만 아니라 두 개의 수직 및 두 개의 수평 가장자리를 각각 결합하는 .vertical 및 .horizontal도 전달한다.
    .edgesIgnoringSafeArea(.all)
  	// 이미지의 채도를 줄인다.
    .saturation(0.5)
  	// 블러족용
    .blur(radius: 5)
  	// 투명도 적용
    .opacity(0.08)
  ```

  ![image-20220213222750116](2.GettingStart~.assets/image-20220213222750116.png)

  위 코드에서는 중복 수정자가 있다.

  `.scaledFit` 수정자인데, 이미 `.resizable`을 사용하여 부모에 맞게 이미지를 만든 다음 .aspectRatio가 대신 부모를 채우도록 이미지를 만든다. `.scaledToFit` 수정자를 주석 처리하면 최종 결과가 변경되지 않는 것을 볼 수 있다.

  `scaledToFit`과 `aspectRatio` switch하면 어떻게 될까? 결과물이 달라질까?

  `.scaledTofit`은 이전 행에서 설정된 채우기 모드를 무시한다. 따라서 중복 수정자가된다. 그러나 종횡비를 2로 변경하면?

  ```swift
  .aspectRatio(2 / 1, contentMode: .fill)
  ```

  이 경우 결과는 상당히 다르다. 높이를 변경하지 않고 너비를 2배로 만들기 때문

  <img src="2.GettingStart~.assets/image-20220213223432689.png" alt="image-20220213223432689" style="zoom:50%;" />

  즉, 이 종횡비 변경을 되돌릴 수 있으며 중복 되는 코드인`.scaledTofit`를 안전하게 삭제할 수 있다.
  그런 다음 코드가 다음과 같다.

  ```swift
  Image("welcome-background", bundle: nil)
    .resizable()
    .scaledToFit()
    .aspectRatio(1/1, contentMode: .fill)
    .edgesIgnoringSafeArea(.all)
    .saturation(0.5)
    .blur(radius: 5)
    .opacity(0.08)
  ```

* 텍스트 분할

  아래의 코드를

  ```swift
  VStack {
    Text("Welcome to")
      .font(.system(size: 30))
      .bold()
      .foregroundColor(.red)
      .multilineTextAlignment(.center)
      .lineLimit(2)
    Text("Kuchi")
      .font(.system(size: 30))
      .bold()
      .foregroundColor(.red)
      .multilineTextAlignment(.center)
      .lineLimit(2)
  }
  ```

  이렇게 리펙토링할 수 있다. (font랑 bold는 `Text`전용 수정자임. `View`, `VStack`에는 적용 불가)

  ```swift
  VStack{
    Text("Welcome to")
      .font(.system(size: 30))
      .bold()
    Text("Kuchi")
      .font(.system(size: 30))
      .bold()
  }
  .foregroundColor(.red)
  .multilineTextAlignment(.center)
  .lineLimit(2)
  ```

  위의 두 `Text`를 가운데가 아닌 왼쪽 정렬을 하고자 해서 아래 코드를 `VStack`에 적용해봤다.

  ```swift
  VStack{
    ...
  }
  .foregroundColor(.red)
  // --------여기---------
  .multilineTextAlignment(.leading)
  // --------------------
  .lineLimit(2)
  ```

  그러나 동작하지 않는다.
  이는 `Text`를 두개의 서로 다른 `Text`로 분할하고 각 `Text` 크기가 내용에 따라 조정되기 때문. 따라서 TextAlignment를 변경해도 효과가 없음.

  아래 처럼 하면 된다. 

  ```swift
  VStack(alignment: .leading){
    ...
  }
  .foregroundColor(.red)
  .lineLimit(2)
  ```

  라인 제한도 더 이상 필요하지 않다. 그냥 제거해도 되지만 `Text`를 여러 줄에 걸쳐 자유롭게 만들 수 있다. 이 경우 거의 발생하지 않지만 다음과 같이 변경하여 각 `Text`View가 한줄에만 보여줄 수 있도록 1로 변경해준다.

  ```swift
  VStack(alignment: .leading){
    ...
  }
  .foregroundColor(.red)
  .lineLimit(1)
  ```

* SwiftUI 3.0에서 부터는 Text에 md 문법이 지원된다.

  ```swift
  Text("**Welcome to**")
  	.font(.headline)
  Text("**Kuchi**")
  	.font(.largeTitle)
  ```

  와

  ```swift
  Text("Welcome to")
    .font(.headline)
    .bold()
    Text("Kuchi")
    .font(.largeTitle)
    .bold()
  ```

  는 동일한 결과를 출력한다.

* Label: `Image`와 `Text` 결합

  SwiftUI에서 `Image`와 `Text`의 결합은 매우 쉽다. `HStack`이나 `Vstack` 을 이용해도 되지만 작업을 쉽게하기 위해 `Label`을 이용한다.

  ```swift
  Label("Welcome", systemImage: "hand.wave")
  ```

  위 코드는 아래 결과를 출력한다.

  ![image-20220213230501183](2.GettingStart~.assets/image-20220213230501183.png)

  또한 `Text` 및 `Image`에 대한 사용자 정의 View를 제공할 수 있다.

  이 이니셜라이저는 title과 icon의 두 가지 매개변수를 사용하며 다음과 같다.

  ```swift
  init(title: () -> Title, icon: () -> Icon)
  ```

  아래 코드를 리펙토링해보자

  ```swift
  HStack {
    Image(systemName: "table")
      .resizable()
      .frame(width: 30, height: 30)
      .overlay(Circle().stroke(Color.gray, lineWidth: 1))
      .background(Color(white: 0.9))
      .clipShape(Circle())
      .foregroundColor(.red)
  
    VStack(alignment: .leading) {
      Text("Welcome to")
        .font(.headline)
        .bold()
      Text("Kuchi")
        .font(.largeTitle)
        .bold()
    }
    .foregroundColor(.red)
    .lineLimit(1)
    .padding(.horizontal)        
  }
  ```

  `Image`는 `Label`의 icon 매개 변수로, VStack (수정자와 함께)은 title 매개 변수로 이동한다.

  ```swift
  Label {
    // Text component
    VStack(alignment: .leading) {
      Text("Welcome to")
        .font(.headline)
        .bold()
      Text("Kuchi")
        .font(.largeTitle)
        .bold()
    }
    .foregroundColor(.red)
    .lineLimit(2)
    .multilineTextAlignment(.leading)
    .padding(.horizontal)
  } icon: {
    // Image component
    Image(systemName: "table")
      .resizable()
      .frame(width: 30, height: 30)
      .overlay(Circle().stroke(Color.gray, lineWidth: 1))
      .background(Color(white: 0.9))
      .clipShape(Circle())
      .foregroundColor(.red)
  }
  ```

  위 코드를 적용하면 아이콘과 글자가 세로로 정렬되지 않았다는 것을 볼 수 있다.

  <img src="2.GettingStart~.assets/image-20220213231058098.png" alt="image-20220213231058098" style="zoom:50%;" />

  위 문제를 해결하려면 `Label`이 제공해주는 스타일을 적용해야 한다는 것이다. 문제는 기본적으로 사용가능한 것이 우리의 요구사항에 맞지 않다는 것이다.

  * `DefaultLabelStyle`: 스타일을 지정하지 않은 기본값. title, icon을 표시
  * `IconOnlyLabelStyle`: icon만 표시
  * `TitleOnlyLabelStyle`: title만 표시

  다행인것은 LabelStyle을 직접 구현할 수 있다.

  `LabelStyle` 프로토콜을 채택하는 구조체를 구현하면 된다. 아래 메서드를 구현하면 된다.

  ```swift
  func makeBody(configuration: Self.Configuration) -> Self.Body
  ```

  커스텀 `LabelStyle`을 만들자

  ```swift
  struct HorizontallyAlignedLabelStyle: LabelStyle {
      func makeBody(configuration: Configuration) -> some View {
          HStack{
              configuration.icon
              configuration.title
          }
      }
  }
  ```

  그리고 `Label` 에 적용

  ```swift
  Label{
    ...
  }
  .labelStyle(HorizontallyAlignedLabelStyle())
  ```

## 6. Controls & User Input

* 여기서는 `TextField`, `Button`, `Stepper`등과 같이 사용자 입력에 일반적으로 사용되는 컨트롤에 대해 알아보도록 한다.

* 배경 이미지가 ` .fill` 콘텐츠 모드로 되어 있으면 가능한 한 많은 부모 View를 차지하도록 이미지가 확장된다.

  이때 `TextField`같은 View를 넣으면 아래처럼 배경 이미지 크기에 맞춰서 잡힌다.(너무 길다...)

  <img src="2.GettingStart~.assets/image-20220213234916044.png" alt="image-20220213234916044" style="zoom:50%;" />

  이를 해결하는 가장 멋진 방법은 `ZStack` 대신에 `.background`수정자를 이용하여 실제 콘텐츠 뒤에 배경 View를 배치하는 것을 피하는 것이다.

  ```swift
  var body: some View {
    VStack {
      WelcomeMessageView()
      TextField("Type your name...", text: $name)
    }
    .background(WelcomeBackgroundImage())
  }
  ```

  근데 이렇게하면 배경이미지가 너무 작게 보이는 문제가 발생한다.

  `VStack`은 전체화면을 사용하는 것이 아니라 content를 렌더링하는 데 필요한 만큼만 사용하기 때문.

  아래 스크린샷의 파란색 테두리가 VStack의 실제 크기이다.

  <img src="2.GettingStart~.assets/image-20220213235320364.png" alt="image-20220213235320364" style="zoom:50%;" />

  이 문제를 해결하려면 다음과 같이 `VStack`의 시작 부분과 끝에 두개의 `Spacer`를 추가해준다.

  ```swift
  VStack {
    Spacer()
  
    WelcomeMessageView()
    TextField("Type your name...", text: $name)
  
    Spacer()
  }
  .background(WelcomeBackgroundImage())
  ```

  나중에 `Spacer` 에 좀 더 자세히 배우게 될 것인데, 지금 알아야 할 것은 모든 공간을 사용할 수 있도록 확장시켜준다는 것이다.

* TextField 스타일

  `.textFieldStyle(_:)`을 이용해 textfield 스타일을 지정할 수 있다.

  총4가지가 제공됨.

  ![image-20220213235811350](2.GettingStart~.assets/image-20220213235811350.png)

  사실 5번째인 `SquareBorderTextFieldStyle`도 있는데 macOS에서만 사용가능하다.

  NoStyle, DefaultTextFieldstyle, PlainTextFieldStyle 은 차이가 없다.

  RoudnedBorderTextFieldStyle은 모서리가 약간 둥근 테두리가 있다.

  우리가 custom한 TextField를 사용하는 방법은 3가지가 있다. 

  * 필요에 따라 TextField에 수정자를 적용
  * `TextFieldStyle` 프로토콜을 준수하는 type을 정의하여 `TextFieldStyle`을 직접 만든다.
  * `ViewModifier`프로토콜을 준수하는 type을 정의하여 수정자를 직접 만든다.

  여기서는 첫번째 방법을 사용하도록 한다.

  ```swift
  TextField("Type your name...", text: $name)
    .padding(
    	EdgeInsets(top: 8, leading: 16, bottom: 8, trailing: 16)
    )
    .background(Color.white)
    .overlay(RoundedRectangle(cornerRadius: 8)
    					.stroke(lineWidth: 2)
    					.foregroundColor(.blue)
    )
    .shadow(color: Color.gray.opacity(0.4), radius: 3, x: 1, y: 2)
  ```

  아래 스크린샷은 각 수정자의 효과를 보여준다.

  ![image-20220214000515282](2.GettingStart~.assets/image-20220214000515282.png)

  1. 수정되지 않은 TextField
  2. 세로 16, 가로8의 패딩을 추가
  3. 불투명한 흰색 배경을 추가
  4. 모서리 반경인 8인 둥근 사각형을 사용하여 테두리 오버레이를 만든다.
  5. 테두리만 유지하고 뒤에 내용은 표시되도록 stroke 효과를 추가한다.
  6. 테두디를 파란색을 만든다.
  7. 그림자 추가

* 사용자 정의 TextFieldStyle 을 이용한 방법

  `TextFiledStyle`을 채택하는 struct를 만든다. 구현해야할 메서드는 아래와 같다. 

  ```swift
  public func _body(configuration: TextField<Self._Label>) -> some View
  ```

  구현하면 아래와 같이 할 수 있다.

  ```swift
  struct KuchiTextStyle: TextFieldStyle{
      public func _body(configuration: TextField<Self._Label>) -> some View{
          return configuration
              .padding(
                  EdgeInsets(top: 8, leading: 16, bottom: 8, trailing: 16)
              )
              .background(Color.white)
              .overlay(RoundedRectangle(cornerRadius: 8)
                          .stroke(lineWidth: 2)
                          .foregroundColor(.blue)
              )
              .shadow(color: Color.gray.opacity(0.4), radius: 3, x: 1, y: 2)
      }
  }
  ```

  그리고 Style을 적용하는 코드는 아래와 같다.

  ```swift
  TextField("Type your name...", text: $name)
  	.textFieldStyle(KuchiTextStyle())

* 사용자 지정 수정자를 이용한 방법

  `ViewModifier` 프로토콜을 채택하는 struct를 하나 만든다.

  해당 struct는 아래를 구현해야 한다.

  ```swift
  func body(content: Content) -> some View {
    content
  }
  ```

  일반적으로 수정자를 적용한 View를 리턴한다.

  ```swift
  struct BorderedViewModifier: ViewModifier {
      func body(content: Content) -> some View {
          content
              .padding(
                  EdgeInsets(top: 8, leading: 16, bottom: 8, trailing: 16)
              )
              .background(Color.white)
              .overlay(RoundedRectangle(cornerRadius: 8)
                          .stroke(lineWidth: 2)
                          .foregroundColor(.blue)
              )
              .shadow(color: Color.gray.opacity(0.4), radius: 3, x: 1, y: 2)
      }
  }
  ```

  `ModifiedContent`구조체 인스턴스를 생성하고 거기에 modifier를 적용하는 방식을 써야 한다.

  해당 init은 아래 파라미터를 필요로 하다.

  * content:
  * modifier:

  ```swift
  ModifiedContent(
    content: TextField("Type your name...", text: $name),
    modifier: BorderedViewModifier()
  )
  ```

  근데 이 방법은 구리다. 일반 수정자처럼 `.` 을 이용해서 호출하면 더 좋아보일 것이다.

  `View` extension을 이용해 메서드를 생성하면 된다.

  ```swift
  extension View{
      func bordered() -> some View{
          ModifiedContent(content: self, modifier: BorderedViewModifier())
      }
  }
  ```

  적용하면 다음과 같다.

  ```swift
  TextField("Type your name...", text: $name)
  	.bordered()
  ```

  깔끔

* TextField에서 입력을 할 때 키보드를 보면 return표시 키가 매핑되어 있지만,

  <img src="2.GettingStart~.assets/image-20220214002702452.png" alt="image-20220214002702452" style="zoom:50%;" />

  이동하려는 필드가 더 있는 경우 "next",
  더이상 없는 경우 "done"으로 변경되도록 하고 싶다.

  TextField의 수정자를 사용한다.

  ```swift
  .submitLabel(.done)
  ```

  이렇게 하면 키보드가 "return" 대신 "done"으로 나오지만 "next"나 "continue" 등등은? 나중에 보도록 하자.

  <img src="2.GettingStart~.assets/image-20220214002636027.png" alt="image-20220214002636027" style="zoom:50%;" />

* SwiftUI3.0에서 사용할 수 있는 기능중에 포커스가 있는 컨트롤을 언제든지 지정하고 알 수 있는 기능이 있다.

  이를 사용하려면 `View`에 `Hashable`을 채택하는 property가 있어야 한다.

  ```swift
  struct RegisterView: View {
    // Add this enum
    enum Field: Hashable {
      case name
    }
    @FocusState var focusedField: Field?
    ...
  }
  ```

  enum 케이스와 텍스트 필드 간의 연결을 생성해야 한다. 이것은 양방향 바인딩이므로 다음이 가능하다.

  * enum케이스가 `focusField`에 할당되면 연결된 component가 포커스를 받는다.
  * component가 사용자의 작업에 대한 응답으로 포커스를 얻으면 (사용자 작업에 대한 응답으로) `focusedField` 프로퍼티는 해당 enum 케이스로 설정된다.

  바인딩은 포커스 상태 프로퍼티 바인딩과 component에 연결된 값을 결정하는 값을 취하는 수정자를 사용하여 수행된다.
  다음과 같이 텍스트 필드에 `.focused` 수정자를 추가한다.

  ```swift
  TextField("Type your name...", text: $userManager.profile.name)
    // Add this modifier
    .focused($focusedField, equals: .name)
    .submitLabel(.done)
    .bordered()
  ```

  이 수정자를 사용하면 SwiftUI에 다음과 같이 알릴 수 있다.

  * `focusField`가 `.name`인 경우 이 텍스트 필드에 포커스를 지정한다.
  * 이 필드가 포커스를 받으면 `focusField`를 `.name`으로 설정한다.

  



